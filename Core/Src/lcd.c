#include "lcd.h"

#include "stm32h7xx_hal_def.h"
#include <string.h>

// framebuffer stored in 320K SRAM1
__attribute__((section(".ram_d1"))) uint8_t fb[800 * 400];
// color look-up table
uint32_t CLUT[256];

// populate once, change .Channel during runtime and reconfig to get ADC
// readings from two pins
ADC_ChannelConfTypeDef adc_conf;

void init_display() {
    // point LTDC to framebuffer
    HAL_LTDC_SetAddress(&hltdc, (uint32_t)fb, LTDC_LAYER_1);

    // rgb332 to rgb888 conversion
    for (uint8_t rgb332 = 0; rgb332 != 255; rgb332++) {
        // LTDC_LxCLUTWR[31:0]: CLUTADD[7:0] RED[7:0] GREEN[7:0] BLUE[7:0]
        uint8_t r = (uint32_t)(((rgb332 & 0xE0) >> 5) * 255 / 7);
        uint8_t g = (uint32_t)(((rgb332 & 0x1C) >> 2) * 255 / 7);
        uint8_t b = (uint32_t)((rgb332 & 0x03) * 255 / 3);
        // Each word in the array will be written to the CLUTWR register of
        // layer 1. Such write happens for 256 times.
        CLUT[rgb332] = (rgb332 << 24) + (r << 16) + (g << 8) + b;
    }
    // point LTDC to CLUT
    HAL_LTDC_ConfigCLUT(&hltdc, CLUT, 256, LTDC_LAYER_1);
    // load CLUT
    HAL_LTDC_EnableCLUT(&hltdc, LTDC_LAYER_1);
}

void test_display() {
    for (int line = 0; line <= LCD_RENDER_HEIGHT; line++) {
        uint8_t color;
        if (line < LCD_RENDER_HEIGHT / 4) {
            // R
            color = 0b11100000;
        } else if (line < LCD_RENDER_HEIGHT / 2) {
            // G
            color = 0b00011100;
        } else if (line < LCD_RENDER_HEIGHT / 4 * 3) {
            // B
            color = 0b00000011;
        } else {
            // Miku 39c5bb is R: 2, G: 5, B: 2 = 0b01010110
            color = 0b01010110;
        }
        memset((void *)(fb + line * LCD_RENDER_WIDTH), color, LCD_RENDER_WIDTH);
    }
}

static uint16_t read_x() {
    // XL: GND, XR: V+, YU: float, YD: ADC
    GPIO_InitTypeDef s = {0};

    s.Pin = LCD_X_L_PIN;
    s.Mode = GPIO_MODE_OUTPUT_PP;
    s.Pull = GPIO_PULLDOWN;
    HAL_GPIO_Init(LCD_X_L_PORT, &s);
    HAL_GPIO_WritePin(LCD_X_L_PORT, LCD_X_L_PIN, GPIO_PIN_RESET);

    s.Pin = LCD_X_R_PIN;
    s.Mode = GPIO_MODE_OUTPUT_PP;
    s.Pull = GPIO_PULLUP;
    HAL_GPIO_Init(LCD_X_R_PORT, &s);
    HAL_GPIO_WritePin(LCD_X_R_PORT, LCD_X_R_PIN, GPIO_PIN_SET);

    s.Pin = LCD_Y_U_PIN;
    s.Mode = GPIO_MODE_INPUT;
    s.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(LCD_Y_U_PORT, &s);

    s.Pin = LCD_Y_D_PIN;
    s.Mode = GPIO_MODE_ANALOG;
    s.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(LCD_Y_D_PORT, &s);
    adc_conf.Channel = LCD_Y_D_ADC_CHAN;
    HAL_ADC_ConfigChannel(&hadc1, &adc_conf);

    HAL_ADC_Start(&hadc1);
    HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
    uint16_t x = HAL_ADC_GetValue(&hadc1);
    HAL_ADC_Stop(&hadc1);
    return x;
}

static uint16_t read_y() {
    // YU: GND, YD: V+, XL: float, XR: ADC
    GPIO_InitTypeDef s = {0};

    s.Pin = LCD_Y_U_PIN;
    s.Mode = GPIO_MODE_OUTPUT_PP;
    s.Pull = GPIO_PULLDOWN;
    HAL_GPIO_Init(LCD_Y_U_PORT, &s);
    HAL_GPIO_WritePin(LCD_Y_U_PORT, LCD_Y_U_PIN, GPIO_PIN_RESET);

    s.Pin = LCD_Y_D_PIN;
    s.Mode = GPIO_MODE_OUTPUT_PP;
    s.Pull = GPIO_PULLUP;
    HAL_GPIO_Init(LCD_Y_D_PORT, &s);
    HAL_GPIO_WritePin(LCD_Y_D_PORT, LCD_Y_D_PIN, GPIO_PIN_SET);

    s.Pin = LCD_X_L_PIN;
    s.Mode = GPIO_MODE_INPUT;
    s.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(LCD_X_L_PORT, &s);

    s.Pin = LCD_X_R_PIN;
    s.Mode = GPIO_MODE_ANALOG;
    s.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(LCD_X_R_PORT, &s);
    adc_conf.Channel = LCD_X_R_ADC_CHAN;
    HAL_ADC_ConfigChannel(&hadc1, &adc_conf);

    HAL_ADC_Start(&hadc1);
    HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
    uint16_t y = HAL_ADC_GetValue(&hadc1);
    HAL_ADC_Stop(&hadc1);
    return y;
}

void init_touch() {
    // generated by CubeMX
    adc_conf.Rank = ADC_REGULAR_RANK_1;
    adc_conf.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
    adc_conf.SingleDiff = ADC_SINGLE_ENDED;
    adc_conf.OffsetNumber = ADC_OFFSET_NONE;
    adc_conf.Offset = 0;
    adc_conf.OffsetSignedSaturation = DISABLE;
    // CubeMX end
}

int read_touch(lv_disp_drv_t *_, lv_indev_data_t *data) {
    // if no touch, x and y value should persist
    static uint16_t x = 0;
    static uint16_t y = 0;

    uint16_t newX = read_x();
    uint16_t newY = read_y();

    if (newX == 0 && newY == 0) {
        data->point.x = x;
        data->point.y = y;
        data->state = LV_INDEV_STATE_REL;
    } else {
        x = newX;
        y = newY;
        data->point.x = x;
        data->point.y = y;
        data->state = LV_INDEV_STATE_PR;
    }

    return 0;
}